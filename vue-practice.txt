3-5.프로젝트 구조와 실행방법

.md(markdown문법)

assets
components

App.vue

main.js

index.html


개발서버 실행
npm run serve

http://localhost:8080/


배포


serve
build
lint


번들링


3-6.프로젝트 원리 경험하기 

webpack -번들러

https://webpack.js.org/

번들링을 하는 이유
- 효율적/용량이 적도록

npm init -y

npm install webpack webpack-cli --save-dev

npx webpack

npm/ npx


babel

npm install babel-loader @babel/core @babel/preset-env --save-dev

npx webpack

npx webpack --watch

3-7. 텍스트 바인딩

npm run serve

SET PATH=C:\Program Files\nodejs;%PATH%

*extension

1.vetur
2.Vue 3 snippets
3.prettier


ctrl + shift + p

머스태취 {{}}
directive
v-text
v-html - 보안상 문제가 발생할 소지가 있다.
       - v-html에 특정 코드를 삽입해서 사용할 수도 있기 때문에
         믿을 수 있는 경우(외부에서 가져 올 경우)에만 사용해야 함.


3-8.클래스 바인딩

attr: attribute(html 코드 속성)

v-bind:id="dynamicId"

<a v-bind:href="url">naver</a>

<img v-bind:src="image.src" v-bind:alt="image.alt" /><br />

<input v-bind:type="inputType" />

 <p v-bind:style="pStyle">Hello Vue!</p>

3-9.클래스 (동적)바인딩


<h2 v-bind:class="textDecoration">line-through</h2>

<h2 :class="isDone === true ? 'line-through' : 'highlight'">
      line-through
</h2>

<!--
      1.조건 ? 참일경우: 아닐경우
      2. 오브젝트 형태 조건 
      3. 배열 형태
      -->

*3-10.조건부 랜더링
<h1 v-once v-text="user.name"></h1>
<h1 v-text="user.name"></h1>
<input type="text" v-model="user.name" />

<h2 v-if="showName">My name is {{ user.name }}</h2>
<h2 v-else>이름을 보여줄 수 없습니다.</h2>

<h2 v-if="user.age > 20">당신은 성인입니다.</h2>
    <h2 v-else-if="user.age > 14 && user.age < 20">당신은 청소년입니다.</h2>
    <h2 v-else>당신은 어린이 입니다.</h2>

<h2 v-if="!showName">{{ user.name }} IF</h2>
<h2 v-show="!showName">{{ user.name }} Show</h2>
=> <h2 style="display:none;">

template tag

3-11.리스트 렌더링      

v-for

중첩반복문

3-12.조건부 리스트 렌더링

 v-if 와  v-for를 같이 사용할 수 없다.
 alt + shift + a : 블럭단위 주석처리 가능 

 template

 3-13.메서드
- 함수
data()에 있는 age에 접근하는 방법 
this.age 

//TypeError: Cannot read properties of undefined (reading 'age')

화살표 함수의 특징
lexical scope
함수에 선언에 따라 스코프가 결정
(즉, 호출에 영향 받지 않고 고정 된다는 뜻입니다.)

메서드를 선언할 때는 일반함수 형태로 선언하라.(화살표 함수로 하지 말고)


3-14. 이벤트 핸들링
<button v-on:click="changeName">change name</button>
    <button
      v-on:mouseover="name = 'Code Scalper'"
      v-on:mouseleave="name = 'Scalper'"
    >

modifier

left:왼 클릭
middle:휠 클릭
right: 오른 클릭

 <a v-on:click.prevent="movePage" href="https://naver.com">naver로 이동</a>

*modifier
 stop, capture, self, once, passive, prevent

 3-15.Form 핸들링

 Ime(Input Method Editor)
 :자판에 있는 글쇠보다 수가 많은 문자를 조합하여 입력해 주는 시스템

 v-on:input = @input
 setValue(e) {
      console.log(e.target.value);
      this.user.name = e.target.value;
    },

3-16.Directives    

v-on:click = @click

v-once
v-pre:컴파일에서 제외된 채로 화면에 출력이 된다.
*사용자 정의 directives
-mounted등 라이프 사이클의 내용은 추후 설명 
directives: {
    focus: {
      mounted(el) {
        el.focus();
      },
    },
  },

  뷰의 라이프사이클 

3-17.computed
-data와 흡사
-계산된 값을 제공하는 속성
* 디스트럭쳐링
const { math, kor, eng, sci } = this.grade;
      return math + kor + eng + sci;
      //return this.grade.math + this.grade.kor + this.grade.eng + this.grade.sci;

computed로 작성된 값이 캐쉬가 되기때문에,관련된 값의 실질적인 변화가 있을 때 실행된다.
methods로 선언된 것은 화면의 값의 변동이 있을때마다 수행된다.

3-18.watch
-데이터의 변경이 일어나는 것을 감시하고
인지하는 역할을 한다.

//오브젝트 watch 하는 방법 
 receit: {
      handler(newValue) {
        console.log("영수증에 값 변화", newValue);
      },
      deep: true,
    },

최초에 들어왔을때도 발동이 되게 하려면
immediate:true 

userName: {
      handler(newValue) {
        console.log(newValue, "newValue");
      },
      immediate: true,
    },

3-19.컴포넌트1
export default {
  name: "GreetingUser",
  props: {
    //username: String,
    username: {
      type: String,
      default: "User!",
    },
  },
};

3-20.컴포넌트2
 siteInfo: {
      // Object의 초기화
      type: Object,
      default: () => {
        return { name: "-", teacher: "-" };
      },
    },

3-21.component3

v-bind:src = :src

non-props 속성
v-bind="$attrs"

inheritAttrs:false,


3-22.component4
부모와 자식간 이벤트를 전달하고 전달 받는 방법
prop으로 넘겨받은 값은 수정할 수 없습니다.
단, prop의 property는 수정할 수 있습니다.
ex) user.name = 'scalper'(O)
user = {name:'scalper'} (X)

 closeDetail() {
      this.$emit("closeDetail"); //부모로 이벤트 전달
    },

컴포넌트에서 데이터를 전달받는 방법
 sendData() {
      this.$emit("sendData", this.username, this.id); //부모로 이벤트 전달
    },

3-23.component5
-provide:데이터를 보내는 곳에서 선언
-inject:데이터를 받을 곳에서 선언 
-dynamic import 

Vue-Vuex [Global State Management]
React-Redux
Angular-Angular Universal

<component :is="activeTab"></component>
작성한 내용을 유지시켜주는 기능 => keep-alive
<keep-alive>
      <component :is="activeTab"></component>
    </keep-alive>

3-24.슬롯
-템플릿 자체를 넘겨서 내용을 만들때 유용하다.


3-25.텔레포트(teleport)
- 게임에서 처럼 순간이동 같은거
- 다른 엘레멘트로 이동시킬수 있다.

3-26.HTTP Request
axios
https://axios-http.com/docs/intro

https://github.com/axios/axios

npm install axios --save


https://jsonplaceholder.typicode.com/

3-27.Life Cycle
-생명 주기

Creating beforeCreate(), created()

Mounting beforeMount(), mounted()

Updating beforeUpdate(), updated()

Unmounting beforeUnmount(), unmounted()
- destroy(과거)
- 불러온 컴포넌트를 더이상 사용하지 않을때 

misc activated(), deactivated(), errorCaptured()
     renderTracked(), renderTriggered()
Keep-alive 유지할때 - activated(), deactivated() 

3-28.refs
-어떠한 엘리먼트를 직접적으로 선택할수 있도록 돕는다.
ref

3-29.Mixins
-재사용
mixins: [moneyMixin],
공통으로 사용할 수 있다.
mixin에서 사용하는 값과 컴포넌트에서 동일한 값을 
사용하게 되면 컴포넌트의 값이 우선한다.
- 동일하게 반복되는 코드를 줄일수 있다.
- 한곳에서 관리할 수 있다.
- 이러한 문제를 해결하기 위해 Composition API 추가됨.

3-30.컴포지션 API- data.
composition 
import { reactive } from "vue"; //반응성을 가진 데이터로 변신
import { reactive, toRefs } from "vue";
setup() {
    //const username = "scalper";
    const state = reactive({
      username: "Scalper",
      age: 50,
    });
    return toRefs(state);

    //return {
    //state,
    //username: state.username,
    //age: state.age,
    //username,
    //username:username,
    // };
  },
toRefs()
반응성 

import { ref } from "vue";
ref:단일한 데이터를 보내기 위해 사용
reactive : 다양한 데이터를 보내기 위해 사용

 ...toRefs(state),

3-31.컴포지션 API- method, model
method.
v-model

반응성이 주입이 되지 않으면 값이 바뀌지 않는다.


3-32.컴포지션 API- computed, watch 
스프레드 오퍼레이터 ...

3-33.컴포지션 API- Life Cycle
-setup() 재사용하는 방법 
  beforeCreate, created가 사실상 의미가 없다.
  그래서 지원이 되지 않고 있다. 필요가 없다.

event emit

3-34.컴포지션 API- Reusability
재사용성

Vuex
vue router

3-35.배포하기(Deploy) 
npm run build

https://git-scm.com/

https://github.com/richinhim/vue-practice.git

git version

1. git init

2.git status

3.git add .

4. git commit -m 'deploy test'

5. git remote add origin https://github.com/richinhim/vue-practice.git

6.git push -u origin master 

npm run build





